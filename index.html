<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <link href="https://fonts.googleapis.com/css?family=Montserrat:900" rel="stylesheet">
    <title>N2O ECO</title>
    <link rel="stylesheet" href="https://synrc.space/synrc.css?v=6" />
</head>

<body>

<nav>
    <a href='https://synrc.space/'>SYNRC</a>
    <a href='https://o1.network'>O1</a>
    <a href='https://o3.click'>O3</a>
    <a href='https://o7.network'>O7</a>
</nav>

<header>
    <h1>N2O ECO</h1>
</header>

<aside>
    <article>
        <section>
            <h3>SYNOPSIS</h3>
            <div>
                 N2O ECO defines a full stack specification along
                 with reference implementations in functional programming
                 languages. It provides WebSocket and MQTT connectivity
                 with minimalistic enterprise protocol stack: web framework, business process management, scalable data storage.
                 As an example, three N2O implementations presented
                 here in functional languages: Erlang, Haskell, and Standard ML.<br><br>
            </div>
            <div class=logo style="padding:20px;margin-bottom:20px;"><center>
                <img src="Erlang-Mono.svg?v=3" style="width:120px;margin-right:60px;">
                <img src="Haskell-Mono.svg?v=3" style="width:100px;margin-right:60px;">
                <img src="SML-Mono.svg?v=3" style="width:130px;">
            </center></div>
            <div>
                2013&mdash;2019 &copy; <a href="https://5ht.co/license.htm">DHARMA LICENSE</a>
            </div>
        </section>
    </article>
</aside>
<main>
    <section>
        <h3>WHAT IS N2O ECO?</h3>
        <p> N2O ECO is an ecosystem that provides it's own
            application protocol stack, defined in Erlang that can be authomatically
            exposed as ASN.1, Protobuf V3, JSON/REST and already implemented in
            different tires of server programming languages:
            <!-- Tire 0 [Coq, Agda, Lean], -->
            Tire 1 [Erlang, Haskell, Standard ML],
            Tire 2 [Scala/Java, F#/C#, Python, Clojure, Elixir]; compatible with
            different client languages: JavaScript, Swift, Kotlin; and designed
            for WebSocket and MQTT.</p>
        <p> Remember protocol stacks you are already familiar with.
            It could be legacy standards, such as:
            CORBA, DCOM, WSDL, SOAP, XMPP; as well as some latests restricted
            implementations: JVM [Spring, Apache], CLR [WCF, WWF, WPF].
            Recall telecom protocol stacks there are being used as
            complimentary and more underlying layers of protocols defined with ASN.1
            [Bluetooth, WiFi, LDAP, DNS, SS7, GSM, UMTS, SMPP, BGP, AMQP].
            Modern protocol stack tend to use lightweight versions of
            descriptive languages: Thrift, GRPC/Protobuf and
            different protocols: HTTP/2, QUIC, WebSocket, MQTT as well as
            legacy TCP and UDP. That is a reason we chose WebSocket, MQTT
            and QUIC for transport and session layer.</p>
        <p> N2O ECO offers a full-stack specification and implementation for banking,
            messaging and platform development. It specifies the way
            to scale applications, protocols, processes, services, and storage.
            Ready for high-speed, low-latency IoT, MQTT, TCP, UDP and WebSocket
            applications, N2O powers <a href="https://pb.ua/depozit"> banks</a>,
            <a href="https://nynja.io">messaging systems</a>, and several
            startups around America, Europe and Asia.</p>
    </section>
    <section>
         <h3>HOW TO N2O?</h3>
         <figure><figcaption>NITRO ERLANG:</figcaption><code>
  event(init) ->
      wf:reg(room);
  event(chat) ->
      wf:send(room,{client,{peer(),message()}});
  event({client,{P,M}}) ->
      wf:insert_bottom(history,
         #panel{id=history,body=[P,": ",M,#br{}]}).
         </code></figure>
        <figure><figcaption>NITRO Haskell:</figcaption><code>
  index Init = do
      updateText "system" "What is your name?"
      wireEl button{id="send", postback=Just Greet, source=["name"]
  index (Message Greet) = do
      Just name &lt;- get "name"
      updateText "system" ("Hello, " <> jsEscape name <> "!")
  about Init =
      updateText "app" "This is the N2O Hello World App"
        </code></figure>
         <figure><figcaption>KVX ERLANG:</figcaption><code>
  #reader{id=R} = kvs:save(kvs:reader(Id)),
  [ kvs:save(kvs:add((kvs:load_writer(Id))
    #writer{args=#emails{}})) || _ <- lists:seq(1,X) ],
  Bot = kvs:bot(kvs:load_reader(R)),
  #reader{args=F} = kvs:take(Bot#reader{args=20,dir=0}),
         </code></figure>
         <figure><figcaption>BPE ERLANG:</figcaption><code>
  action({request,'Init'}, Proc) ->
    {reply,Proc};

  action({request,'Payment'}, Proc) ->
    Payment = bpe:doc({payment_notification},Proc),
    case is_tuple(Payment) of
         true  -> {reply,'Process',Proc};
         false -> {reply,'Signatory',Proc} end;
         </code></figure>
         <figure><figcaption>REST ERLANG:</figcaption><code>
  init() -> ets:new(users, [public, named_table, {keypos, #user.id}]).
  populate(Users) -> ets:insert(users, Users).
  exists(Id) -> ets:member(users, wf:to_list(Id)).
  get() -> ets:tab2list(users).
  get(Id) -> [User] = ets:lookup(users, wf:to_list(Id)), User.
  delete(Id) -> ets:delete(users, wf:to_list(Id)).
  post(#user{} = User) -> ets:insert(users, User);
  post(Data) -> post(from_json(Data, #user{})).
         </code></figure>
    </section>
    <section>
         <h3>N2O PROTOCOLS</h3>
         <figure><figcaption></figcaption><code>
         </code></figure>
    </section>
    <section>
        <p>Tier 1 — Implementations in functional languages (Erlang, Haskell, Standard ML).</p>
    </section>
    <section>
        <a name=intro></a>
        <h3><a href="https://o7.network">O7 ECO</a></h3>
        <p> O7 ECO defines ecosystem, a full-stack specification and implementation
            for banking, messaging and platform development. It specifies the way
            to scale applications, protocols, processes, services, and storage.
            Ready for high-speed, low-latency MQTT, TCP, QUIC, UDP, and WebSocket
            applications this version of N2O&nbsp;ECO provides: business process management (BPE),
            Nitrogen web framework (NITRO), WebSocket and MQTT connectivity (N2O),
            REST framework, fast and simple package manager (MAD),
            type-driven BERT parser generator for API development,
            scalable data storage (KVX), and many more.
        </p>
            <ul>
                <li><a href="https://ws.n2o.space">o7/n2o</a> &mdash; N2O 5.11.1 MQTT WS</li>
                <li><a href="https://kvx.n2o.space">o7/kvx</a> &mdash; KVX 5.11</li>
                <li><a href="https://mad.n2o.space">o7/mad</a> &mdash; MAD 4.11</li>
                <li><a href="https://bpe.n2o.space">o7/bpe</a> &mdash; BPE 3.11</li>
                <li><a href="https://synrc.github.io/nitro">o7/nitro</a> &mdash; NITRO 3.10</li>
                <li><a href="https://synrc.github.io/rest">o7/rest</a> &mdash; REST 5.10</li>
                <li><a href="https://synrc.github.io/active">o7/active</a> &mdash; ACTIVE 4.11</li>
                <li><a href="https://synrc.github.io/fs">o7/fs</a> &mdash; FS 4.10</li>
                <li><a href="https://synrc.github.io/sh">o7/sh</a> &mdash; SH 2.11</li>
                <li><a href="https://synrc.github.io/bert">o7/bert</a> &mdash; BERT 1.11.1</li>
                <li><a href="https://review.n2o.space">o7/review</a> &mdash; REVIEW 1.11 TT</li>
                <li><a href="https://sample.n2o.space">o7/sample</a> &mdash; REVIEW 1.11 WS</li>
                <li><a href="https://mqtt.n2o.space">o7/mqtt</a> &mdash; N2O 5.11.1 TT</li>
            </ul>

    </section>
    <section>
        <h3><a href="https://o3.click">O3 ECO</a></h3>
         <p>O3 ECO introduces N2O protocols for Haskell programming language.
            It includes full implementation of Nitrogen Web Framework (NITRO) in
            Haskell along with HTML example (SAMPLE)
            driven by WebSocket and static HTTP servers (N2O).</p>
        <ul>
            <li><a href="https://n2o.o3.click">o3/n2o</a> &mdash; N2O 0.11 HS</li>
            <li><a href="https://nitro.o3.click">o3/nitro</a> &mdash; NITRO 0.11</li>
            <li><a href="https://sample.o3.click">o3/sample</a> &mdash; SAMPLE 0.11</li>
        </ul>
    </section>
    <section>
        <a name=intro></a>
        <h3><a href="https://o1.network">O1 ECO</a></h3>
        <p> O1 ECO is a Standard ML N2O implementation. Standard ML (SML)
            is a certified language with formally defined operational semantics.
            Here is yet simple CML loop with INetSock.TCP spawned acceptors.
            Simple enough to handle N2O protocols inside the TCP server.
            O1&nbsp;ECO provides basic WebSocket connectivity and basic
            application server (N2O). The unique feature of SML implementation
            is that O1 ECO is implemented in verified language.
        </p>
        <ul>
            <li><a href="https://n2o.o1.network">o1/n2o</a> &mdash; N2O 0.11 ML</li>
        </ul>
    </section>
    <section>
            <h3>ADVICE TO AUTHOR</h3>
            <p>
                 Each language, N2O is implemented in, should
                 embed N2O most naturally and compact. If some layer between
                 the base library of a language is needed, it
                 could be provided, but it should be reduced
                 to zero if possible. In some cases, some parts
                 of a base library could be replaced with better replacement.
                 N2O should provide client companion library usually
                 implemented in a different set
                 of client languages: JavaScript, Swift, and Kotlin.
                 If you did everything right, N2O should not
                 be more than 500 LOC in any language.
                 The correct way is to implement WebSocket and
                 static HTTP server using the same codebase.<br><br>
            </p>
            <br>
            <br>
    </section>

</main>

<footer>
    Made with <span class="heart">❤</span> to N2O
</footer>

</body>
</html>
